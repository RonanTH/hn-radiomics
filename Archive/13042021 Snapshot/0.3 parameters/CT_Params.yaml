# This is an example of a parameters file
# It is written according to the YAML-convention (www.yaml.org) and is checked by the code for consistency.
# Three types of parameters are possible and reflected in the structure of the document:
#
# Parameter category:
#   Setting Name: <value>
#
# The three parameter categories are:
# - setting: Setting to use for preprocessing and class specific settings. if no <value> is specified, the value for
#   this setting is set to None.
# - featureClass: Feature class to enable, <value> is list of strings representing enabled features. If no <value> is
#   specified or <value> is an empty list ('[]'), all features for this class are enabled.
# - imageType: image types to calculate features on. <value> is custom kwarg settings (dictionary). if <value> is an
#   empty dictionary ('{}'), no custom settings are added for this input image.
#
# Some parameters have a limited list of possible values. Where this is the case, possible values are listed in the
# package documentation

# Settings to use, possible settings are listed in the documentation (section "Customizing the extraction").
setting:
  binWidth: 25
  label: 1
  interpolator: 'sitkBSpline' # This is an enumerated value, here None is not allowed
  resampledPixelSpacing: # This disables resampling, as it is interpreted as None, to enable it, specify spacing in x, y, z as [x, y , z]
  weightingNorm: # If no value is specified, it is interpreted as None
    # first order specific settings:
  voxelArrayShift: 1000  # Minimum value in HU is -1000, shift +1000 to prevent negative values from being squared.
  preCrop: True

# Image types to use: "Original" for unfiltered image, for possible filters, see documentation.
imageType:
  Original: {} # for dictionaries / mappings, None values are not allowed, '{}' is interpreted as an empty dictionary
  Wavelet: {}

  
# Featureclasses, from which features must be calculated. If a featureclass is not mentioned, no features are calculated
# for that class. Otherwise, the specified features are calculated, or, if none are specified, all are calculated (excluding redundant/deprecated features).
featureClass:
  # redundant Compactness 1, Compactness 2 an Spherical Disproportion features are disabled by default, they can be
  # enabled by specifying individual feature names (as is done for glcm) and including them in the list.
  shape:
  firstorder:
  glcm:
  glrlm: # for lists none values are allowed, in this case, all features are enabled
  glszm:
  ngtdm:
  gldm:  # contains deprecated features, but as no individual features are specified, the deprecated features are not enabled




# # This is an example of settings that can be used as a starting point for analyzing CT data. This is only intended as a
# # starting point and is not likely to be the optimal settings for your dataset. Some points in determining better values
# # are added as comments where appropriate

# # When adapting and using these settings for an analysis, be sure to add the PyRadiomics version used to allow you to
# # easily recreate your extraction at a later timepoint:

# # #############################  Extracted using PyRadiomics version: <version>  ######################################

# imageType:
#   Original: {}
#   LoG:
#     sigma: [1.0, 2.0, 3.0, 4.0, 5.0]  # If you include sigma values >5, remember to also increase the padDistance.
#   Wavelet: {}

# featureClass:
#   # redundant Compactness 1, Compactness 2 an Spherical Disproportion features are disabled by default, they can be
#   # enabled by specifying individual feature names (as is done for glcm) and including them in the list.
#   shape:
#   firstorder:
#   glcm:  # Disable SumAverage by specifying all other GLCM features available
#     - 'Autocorrelation'
#     - 'JointAverage'
#     - 'ClusterProminence'
#     - 'ClusterShade'
#     - 'ClusterTendency'
#     - 'Contrast'
#     - 'Correlation'
#     - 'DifferenceAverage'
#     - 'DifferenceEntropy'
#     - 'DifferenceVariance'
#     - 'JointEnergy'
#     - 'JointEntropy'
#     - 'Imc1'
#     - 'Imc2'
#     - 'Idm'
#     - 'Idmn'
#     - 'Id'
#     - 'Idn'
#     - 'InverseVariance'
#     - 'MaximumProbability'
#     - 'SumEntropy'
#     - 'SumSquares'
#   glrlm:
#   glszm:
#   gldm:

# setting:
#   # Normalization:
#   # most likely not needed, CT gray values reflect absolute world values (HU) and should be comparable between scanners.
#   # If analyzing using different scanners / vendors, check if the extracted features are correlated to the scanner used.
#   # If so, consider enabling normalization by uncommenting settings below:
#   #normalize: true
#   #normalizeScale: 500  # This allows you to use more or less the same bin width.

#   # Resampling:
#   # Usual spacing for CT is often close to 1 or 2 mm, if very large slice thickness is used,
#   # increase the resampled spacing.
#   # On a side note: increasing the resampled spacing forces PyRadiomics to look at more coarse textures, which may or
#   # may not increase accuracy and stability of your extracted features.
#   interpolator: 'sitkBSpline'
#   resampledPixelSpacing: [1, 1, 1]
#   padDistance: 10  # Extra padding for large sigma valued LoG filtered images

#   # Mask validation:
#   # correctMask and geometryTolerance are not needed, as both image and mask are resampled, if you expect very small
#   # masks, consider to enable a size constraint by uncommenting settings below:
#   #minimumROIDimensions: 2
#   #minimumROISize: 50

#   # Image discretization:
#   # The ideal number of bins is somewhere in the order of 16-128 bins. A possible way to define a good binwidt is to
#   # extract firstorder:Range from the dataset to analyze, and choose a binwidth so, that range/binwidth remains approximately
#   # in this range of bins.
#   binWidth: 25

#   # first order specific settings:
#   voxelArrayShift: 1000  # Minimum value in HU is -1000, shift +1000 to prevent negative values from being squared.

#   # Misc:
#   # default label value. Labels can also be defined in the call to featureextractor.execute, as a commandline argument,
#   # or in a column "Label" in the input csv (batchprocessing)
#   label: 1
